# -*- coding: utf-8 -*-
"""lab 07 practice

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1jrGLzemwQMBJ7n-khPlmjwxcUZ3bVGNg
"""

import numpy as np
import pandas as pd

df = pd.read_csv('Lab7data.csv')
signal_data=df.values

"""#**Problem 1**#

"""

T=signal_data[:, 0]

Y=signal_data[:, 1]

import matplotlib.pyplot as plt

plt.plot(T, Y)
plt.xlabel("Time, in miliseconds")
plt.ylabel("Signal, in milivolts")
plt.title("Lab 7 data")
plt.show()

"""#**Problem 2**#"""

# This function returns the row [1,cos(t),sin(t), cos(2*t), sin(2*t) , ... , cos(n*t), sin(n*t)] of our matrix X.

def row_func(t,n):
  L = [f(t * k) for k in range(1,n+1) for f in [np.cos, np.sin]]
  L.insert(0, 1)
  return L

"""#**Problem 3**#"""

# This function returns the matrix X, which we call the design matrix.

def design_matrix(n):
  L_matrix = [row_func(t, n) for t in T]
  return np.array(L_matrix)

"""#**Problem 4**#"""

X2 = design_matrix(2)

"""#**Problem 5**#"""

Xt = np.transpose(X2)

# Replace all of the 0 values with the NumPy matrices and vectors requested in Problem 5.

normal_coef2 = np.dot(Xt, X2)

normal_vect2 = np.dot(Xt, Y)

beta2 = np.linalg.solve(normal_coef2, normal_vect2)

"""#**Problem 6**#"""

def f2(t):
    # Compute the row vector for t with n=2 using row_func function
    row_vector = np.array(row_func(t, 2))

    # Compute f2(t) by taking the dot product of beta2 and the row vector
    result = np.dot(beta2, row_vector)

    return result

"""#**Problem 7**#"""

vf2 = np.vectorize(f2)
plt.plot(T, Y, ".")
plt.plot(T, vf2(T), "b-")
plt.show()

"""#**Problem 8**#"""

# Step 1: Calculate predicted values
predicted_values = np.dot(X2, beta2)

# Step 2: Calculate residuals
residuals = predicted_values - Y

# Step 3: Square the residuals
squared_residuals = residuals**2

# Step 4: Calculate mean squared error
MSE2 = np.mean(squared_residuals)

"""#**Problem 9**#"""

X10 = design_matrix(10)

# Compute the coefficient matrix XtX
XtX = np.dot(X10.T, X10)

# Compute the right-hand side XtY
XtY = np.dot(X10.T, Y)

# Find the unique solution beta10
beta10 = np.linalg.solve(XtX, XtY)

predicted_values_10 = np.dot(X10, beta10)

# Calculate the mean squared error (MSE10)
squared_errors_10 = (predicted_values_10 - Y) ** 2
MSE10 = np.mean(squared_errors_10)

# Define the approximating function f10 using beta10
def f10(t):
    row = row_func(t, 10)  # Generate the corresponding row for this time point
    return np.dot(row, beta10)  # Calculate the dot product with beta10

# Generate the predicted value for t=0.105 using f10
t_pred = 0.105
pred10 = f10(t_pred)

MSE10, pred10

# Replace the 0 values with the values requested in Problem 9.  Remember to copy the decimal values from your practice notebook, not the formulas you used to compute them.

MSE10 = 0.009348751458203413

pred10 = 0.5087757565416515

"""#**Problem 10**#"""

# Set up X and Y using n = 100
X100 = design_matrix(100)

# Find the unique solution beta100 to the normal equations
Xt100 = X100.T
normal_coef100 = np.dot(Xt100, X100)
normal_vect100 = np.dot(Xt100, Y)
beta100 = np.linalg.solve(normal_coef100, normal_vect100)

# Compute the mean squared error for n = 100
MSE100 = np.mean((np.dot(X100, beta100) - Y) ** 2)

# Define the approximating function f100 using beta100
def f100(t):
    row = row_func(t, 100)
    return np.dot(row, beta100)

# Generate the predicted value for t=0.105 using f100
t_pred = 0.105
pred100 = f100(t_pred)

MSE100, pred100

# Replace the 0 values with the values requested in Problem 10.  Remember to copy the decimal values from your practice notebook, not the formulas you used to compute them.

MSE100 = 0.0014547562364331276

pred100 = 0.5089902472113171

"""#**Problem 11**#"""

# Step 1: Set up X and Y using n = 1000
X1000 = design_matrix(1000)

# Step 2: Find the unique solution beta1000 to the normal equations
Xt1000 = X1000.T
normal_coef1000 = np.dot(Xt1000, X1000)
normal_vect1000 = np.dot(Xt1000, Y)
beta1000 = np.linalg.solve(normal_coef1000, normal_vect1000)

# Step 3: Compute the mean squared error for n = 1000
MSE1000 = np.mean((np.dot(X1000, beta1000) - Y) ** 2)

# Step 4: Define the approximating function f1000 using beta1000
def f1000(t):
    row = row_func(t, 1000)
    return np.dot(row, beta1000)

# Step 5: Generate the predicted value for t=0.105 using f1000
t_pred = 0.105
pred1000 = f1000(t_pred)

MSE1000, pred1000

# Replace the 0 values with the values requested in Problem 11.  Remember to copy the decimal values from your practice notebook, not the formulas you used to compute them.

MSE1000 = 1.9961406113768612e-28

pred1000 = -14.192461430169898