# -*- coding: utf-8 -*-
"""lab 06 practice

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1GobxvKM63XDQQQjhwNZZ_fgY-Z3Aj3G_

#**Problem 1**

Create NumPy arrays X1 and Y1 using the values in the above matrices X and Y respectively.
"""

import numpy as np

# Replace the values of 0 with the NumPy arrays from Problem 1.

X1 = np.array([[1, 5], [1, 10], [1, 15], [1, 20], [1, 25], [1, 30], [1, 35], [1, 40], [1, 45], [1, 50]])

Y1 = np.array([3.33, 4.43, 4.39, 5.23, 5.67, 6.06, 7.01, 7.16, 8.03, 8.78])

print(X1, Y1)

"""#**Problem 2**

1. Compute the coefficient matrix XtX fo the normal equations and save its value as **normal_coef1**. Recall, the transpose of a NumPy array A can be obtained by np.transpose(A), while the matrix produce of two (appropriately- sized) NumPy arrays A and B is obtained by np.matmul(A, B) or A@B.
2. Compute the right-hand size of XtY of the normal equations, and save its value as **normal_vect1**.
"""

# Replace the values of 0 with the normal equation coefficient matrix and normal equation right-hand side respectively from Problem 2.

# Compute the transpose of X1 to get Xt
Xt = np.transpose(X1)

# Compute XtX by multiplying Xt with X1
XtX = np.matmul(Xt, X1)

# Print or save normal_coef1 (this is the coefficient matrix)
normal_coef1 = XtX

# Compute the right-hand side of XtY
XtY = np.matmul(Xt, Y1)

# Print or save normal_vect1 (this is the right-hand side vector)
normal_vect1 = XtY

print(normal_vect1, normal_coef1)

"""#**Problem 3**"""

# Replace the value of 0 with the least squares solution beta1 you found in Problem 3.

beta1 = np.linalg.solve(normal_coef1, normal_vect1)

# Define a function whose graph is the line of best fit.

def ls1_line(x):
    return beta1[0] + beta1[1] * x

import matplotlib.pyplot as plt

# Construct your plot of ls1_line and the corresponding data points here. Put all of your code to create the plots inside the function below.

def create_plots1():
  # Extract x and y values from X1 and Y1
  x_data = X1[:, 1]
  y_data = Y1[:, 0]

  # Plot the data points
  plt.scatter(x_data, y_data, label="Data Points")

  # Generate values for the line using ls1_line
  x_line = np.linspace(min(x_data), max(x_data), 100)
  y_line = ls1_line(x_line)

  # Plot the line
  plt.plot(x_line, y_line, label="Least Squares Line", color="red")

  # Add labels and a legend
  plt.xlabel("x")
  plt.ylabel("y")
  plt.legend()

  # Show the plot
  plt.show()
  return None

# Replace the value of 0 with your prediction of the satellite's velocity at t=60.

t = 60
pred1 = ls1_line(t)

# test case for problem 3

solution = ls1_line(12.5).item()

print(f"Expected: 4.3030000000000035. Actual: {solution}")

"""#**Problem 4**"""

# Values from Table 2
time_values = [5, 10, 15, 20, 25, 30, 35, 40, 45, 50]
distance_values = [20.57, 87.48, 197.45, 347.67, 546.12, 784.35, 1066.02, 1390.97, 1761.85, 2177.34]

# Convert the lists to NumPy arrays
time_values = np.array(time_values)
distance_values = np.array(distance_values)

# Create NumPy arrays X2 and Y2
X2 = np.column_stack((time_values, time_values**2))
Y2 = distance_values

"""#**Problem 5**"""

# Replace the values of 0 with the normal equation coefficient matrix and normal equation right-hand side, and least squares solution from Problem 5.

normal_coef2 = np.matmul(np.transpose(X2), X2)

normal_vect2 = np.matmul(np.transpose(X2), Y2)

beta2 = np.linalg.solve(normal_coef2, normal_vect2)

print(beta2)

"""#**Problem 6**"""

# Define a function whose graph is the parabola of best fit.
def ls2_par(x):
    return beta2[0] + beta2[1] * x

# Construct your plot of ls2_par and the corresponding data points here. Put all of your code to create the plots inside the function below.

def create_plots2():
  t_values = np.array([5, 10, 15, 20, 25, 30, 35, 40, 45, 50])
  d_values = np.array([20.57, 87.48, 197.45, 347.67, 546.12, 784.35, 1066.02, 1390.97, 1761.85, 2177.34])
  predicted_values = ls2_par(t_values)

  plt.figure(figsize=(8, 6))
  plt.plot(t_values, d_values, 'ro', label='Data Points')
  plt.plot(t_values, predicted_values, 'b-', label='Parabola of Best Fit')
  plt.xlabel('Time (seconds)')
  plt.ylabel('Distance (kilometers)')
  plt.title('Distance vs. Time for the Satellite')
  plt.legend()
  plt.grid(True)
  plt.show()
  return None

# Replace the value of 0 with your prediction of the satellite's position at t=60.

pred2 = ls2_par(60)

# test case for problem 6

solution6 = ls2_par(13.1)

print(f"Expected: 149.73834158597967. Actual: {solution6}")

"""#**Problem 7**"""

# Data from Table 3
semi_major_axes = np.array([0.389, 0.724, 1, 1.524, 5.2, 9.51])
periods = np.array([87.77, 224.70, 365.25, 686.95, 4332.62, 10759.2])

# Create X3 with columns for ln(c) and a
ln_c = np.ones(len(semi_major_axes))
ln_T = np.log(periods)

X3 = np.column_stack((ln_c, ln_T))

# Create Y3 as ln(r)
ln_r = np.log(semi_major_axes)
Y3 = ln_r

# Replace the values of 0 with the normal equation coefficient matrix and normal equation right-hand side from Problem 7.

normal_coef3 = np.dot(X3.T, X3)

normal_vect3 = np.dot(X3.T, Y3)

# Replace the value of 0 with the least squares solution from Problem 7.

beta3 = np.linalg.solve(normal_coef3, normal_vect3)

"""#**Problem 8**"""

# Replace the values of 0 with your predictions for the semi-major axes of Uranus and Neptune.

import numpy as np

# Given periods for Uranus and Neptune
period_Uranus = 30687.15
period_Neptune = 60190.03

# Calculate the natural logarithms of the periods
ln_T_Uranus = np.log(period_Uranus)
ln_T_Neptune = np.log(period_Neptune)

# Get the values of 'a' and 'ln(c)' from the least-squares solution beta3
a = beta3[0]
ln_c = beta3[1]

# Use the model to predict the natural logarithms of the semi-major axes
ln_r_Uranus = ln_c + a * ln_T_Uranus
ln_r_Neptune = ln_c + a * ln_T_Neptune

# Calculate the semi-major axes by taking the exponential
pred_Uran = np.exp(ln_r_Uranus)
pred_Nept = np.exp(ln_r_Neptune)

# Print the predictions
print("Predicted semi-major axis for Uranus:", pred_Uran)
print("Predicted semi-major axis for Neptune:", pred_Nept)