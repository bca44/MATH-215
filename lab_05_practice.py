# -*- coding: utf-8 -*-
"""lab 05 practice

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1PVATyVBgBEy3uAi-scMBHYDjqX45Achu

**LU Decompositions and Gaussian Elimination**

#**Quick Check: Row Reductions**
"""

import numpy as np


def quick_check_1(A):
  #takes matrix A and sets entries in column 1 past row one to 0
  A[1:, 0] = 0
  return A


quick_check_1(np.array([[4,1,3],[-37,4,1],[2,1,-17],[7,7,1]]))

"""#**Quick Check: Slicing Sumatrices and Shape**"""

def quick_check_2(A):
  # takes matrix A and returns 2x2 matrix from bottom right, i.e., the last 2 rows and last 2 columns
  B = np.array([])
  B = A[-2:, -2:]
  return B


quick_check_2(np.array([[3,2,3],[2,4,1],[5,1,1]]))

"""#**PROBLEM 1**

Define a function **agument(A, b)** that accepts as input a matrix **A** and a vector **b** (as NumPy arrays) with the same number of rows, and returns an augmented matrix **[A | b]**.
"""

def augment(A,b):
  #takes a matrix A and a vector B and combines into an augmented matrix
  Ab = np.column_stack((A, b))
  return Ab


augment(np.array([[3,2,1,1], [1,-2,1,1],[5,0,1,5]]), np.array([-1,3,2]))

"""#**PROBLEM 2**

Define a function **first_column_zeros(A)** that accepts as input a matrix **A** (as a NumPy array) with a *nonzero entry in the upper left corner*, and returns a row equivalent matrix **B** whose first column has only one nonzero entry in the top left position. Remember you can assume that the top left entry of **A** is nonzero, though it may not be equal to 1.

In other words, **first_column_zeros(A)** should use row operations (adding appropriate multiples of the first row to the other rows) to create a matrix **B** in which the top left entry is the only nonzero entry in the first column. For grading purposes, your function shouldn't perform any additional row operations other than the ones needeed to create zeros below the top left entry.

NOTE: You will probably need to write a for loop which loops through all of the rows of A except for the first one. Recall that you can include both a starting value and ending value in the function range.
"""

def first_column_zeros(A):
  # takes matrix A and returns a row equivalent matrix B that has each element of B[1:, 0] = 0
  # B[1, 0] = Of matrix B: from row 1 to the end, all of column 0
  B=np.copy(A)
  for i in range(1, len(B)):
    factor = -B[i, 0]/ B[0, 0]
    B[i] = B[i] + factor * B[0]
  return B


first_column_zeros(np.array([[2,1,3,1], [1,2,-1,2.5], [4,2,-1,1]]))

"""#**PROBLEM 3**

Define a function **row_echelon(A, B)** that acceps as input a matrix **A** and vector **b**, and returns an echelon form of the augmented matrix **[A | b]**. The function should perform Gaussian elimination (row reduction) to reduce **[A | b]** to row echelon form. You do not yet need to perform the back substituion that obtains the solution to ** Ax = b**.
"""

import numpy as np

def row_echelon(A, b):
    B = augment(A.copy(), b.copy())
    n = len(B) # number of rows in A
    m = len(B[0]) # length of row 0 of B, i.e., number of columns in A

    for col in range(m):
      for i in range(col + 1, n):
          factor = -B[i, col] / B[col, col]
          B[i] = B[i] + factor * B[col]
    return B


row_echelon(np.array([[3., 1., -2.], [1., 2., -5.], [2., -4., 1.]]), np.array([1.1, 2., -3.]))

"""#**PROBLEM 4**

Define a function **LU_decomposition(A)** which accepts an input a matrix **A**, and returns the matrices **L** and **U**. You may assume that the matrix **A** is invertible and that row operations do not produce zeros on the diagonal.
"""

def LU_decomposition(A):
    n = len(A)  # Assuming A is a square matrix of size n x n.

    # Initialize L as an identity matrix and U as a copy of A.
    L = np.identity(n)
    U = np.copy(A)

    for j in range(n):
        # Iterate over columns.
        for i in range(j + 1, n):
            # Calculate the elimination multiplier Lij.
            L[i, j] = U[i, j] / U[j, j]

            # Update rows below the pivot element.
            U[i, j:] -= L[i, j] * U[j, j:]

    return L, U

# TEST CASE for problem 4
L, U = LU_decomposition(np.array([[3, 1, -2], [1.5, 2, -5], [2, -4, 1]]))
print(f"Expected L: ([[1, 0, 0], [0.5, 1, 0], [0.666667, -3.111111, 1]]). Actual L: {L}")
print(f"Expted U: ([[3, 1, -2], [0, 1.5, -4], [0, 0, -10.1111]]). Acutal U: {U}")

"""#**PROBLEM 5**

Using the above pseudcode, define a function **forward_substituion(L, b)**, which accepts as input a square lower triangular matrix **L** and a vector **b** and returns a vector **y** which is the solution to **Ly = b**.
"""

def forward_substitution(L, b):
    n = len(b)
    # Initialize an empty vector y of size n
    y = np.zeros(n)
    for i in range(n):
        for j in range(i):
            y[i] += L[i, j] * y[j]
        y[i] = (b[i] - y[i]) / L[i, i]

    return y

# test case for problem 5

L, b = np.array([[1, 0, 0], [3, 1, 0], [-1.1, 2, 1]]), np.array([-2.1, 1, -1])
y = forward_substitution(L, b)

print(f"Expected y: array([-2.1, 7.3, -17.91]). Actual y: {y}")

"""#**PROBLEM 6**

Define a function **back_substituion(U, y)**, which accepts as input a square lower triangular matrix **L** and returns a vector **y** which is the solution to **Ly = b**.
"""

def back_substitution(U, y):
    n = len(y)
    x = np.zeros(n)

    for i in range(n - 1, -1, -1):  # Start from the last row and move backward
        x[i] = y[i]  # Initialize x[i] with the corresponding value from y
        for j in range(i + 1, n):
            x[i] -= U[i, j] * x[j]
        x[i] /= U[i, i]

    return x

# test case for problem 6

U, y = np.array([[2, -3.1, 1], [0, 1, 3], [0, 0, 4]]), np.array([1, -2.1, 3])

x = back_substitution(U, y)

print(f"Expected value: array([-6.6175, -4.35, 0.75]). Actual value: {x}")

"""#**PROBLEM 7**

Define a function **LU_solver(A, b)**, which accepts as input a square matrix **A** and a vector **b** and returns the solution **x** to **Ax = b**. We assume that the matrix **A** is invertible and that row operations do not produce zeros on the diagonal. Thus, **LU_solver** may call the functions **LU_decomposition, back_substitution** and **forward_substituion.**
"""

def LU_solver(A, b):
    # Perform LU decomposition on A to get L and U
    L, U = LU_decomposition(A)

    # Solve Ly = b using forward substitution
    y = forward_substitution(L, b)

    # Solve Ux = y using back substitution
    x = back_substitution(U, y)

    return x

# test case for problem 7

A, b = np.array([[3, 1, -2], [1.5, 2, -5], [2, -4, 1]]), np.array([1.1, 3, -2])

x = LU_solver(A, b)

print(f"Expected: array([-0.07032967, 0.34395604, -0.48351648]). Actual: {x}")