# -*- coding: utf-8 -*-
"""lab 03 practice

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1mpY4An0zd27tzougi7IlhEJinBwyEMCT

#**LINE PLOTS**
"""

import numpy as np

from matplotlib import pyplot as plt

#Creates an array with 11 evenly spaces points between -5 and 5
x = np.linspace(-5,5,11)

#prints out array x
print("x= ", x)

#creates an array where each of the points in x is squared
y = x**2

#prints out array y
print("y= ", y)

#to visualize the plot:
plt.plot(y) #creates the line plot
plt.show() #displays the resulting plot

x = np.linspace(-5,5,50) #50 points for a smoother looking graph
y = x**2

plt.plot(x,y) #include x in the plt.plot() function to get the correct domain on bottom

# you can also include labels or a title using plt.xlabel(), plt.ylabel(), and plt.title(), among other things
plt.show()

"""#**SCATTER PLOTS**"""

# get 500 random samples from two normal distributions
x = np.random.normal(scale = 1.5, size = 500)
y = np.random.normal(scale = 1, size = 500)

# draw a scatter plot of x against y, using transparent circle markers
plt.plot(x,y,'o', markersize = 2, alpha = 1) # markersize = size of the dots plotted, alpha = transparency, where 1 is opaque and 0 transparent
plt.show()

"""Problem 1: Plot the functions sin(x) and cox(4x) on the domain [-2pi, 2pi]. Create both graphs on the same plot, and make sure the domain is refined enough to produce a figure with good resolution. Use np.pi for pi, and np.sin and np.cos for sin and cos respectively."""

import numpy as np
from matplotlib import pyplot as plt

def problem_1():
    # Create an array for domain x
    x = np.linspace(-2 * np.pi, 2 * np.pi, 500)

    # Create our output arrays
    y1 = np.sin(x)
    y2 = np.cos(4 * x)

    # Create a plot for y1 (sine) with a blue solid line
    plt.plot(x, y1, label='sin(x)', color='blue', linestyle='-')

    # Create a plot for y2 (cosine) with a red dashed line
    plt.plot(x, y2, label='cos(4x)', color='red', linestyle='--')

    # Add labels, a legend, and a title
    plt.xlabel('x')
    plt.ylabel('y')
    plt.title('Plot of sin(x) and cos(4x)')
    plt.legend()

    plt.show()
    return None

problem_1()

"""Problem 2: Generate a scatter plot identical to the one described below, but now with the points being shown as x’s rather than o’s and with the markers being completely opaque(not transparent at all)."""

def problem_2():
    # Get 500 random samples from two normal distributions.
    x = np.random.normal(scale=1.5, size=500)
    y = np.random.normal(scale=1, size=500)

    # Draw a scatter plot of x against y, using opaque 'x' markers.
    plt.plot(x, y, 'x', markersize=5, alpha=1)
    plt.show()

    # Return None
    return None

problem_2()

"""#**ITERATIVE AND RECURSIVE TECHNIQUES**"""

# code the FIbonacci sequence. make a program fib(n) which computes the Nth fibonacci number, using recursion
# defined by: x0 = 1, x1 = 1, xN = xN-1 + xN-2 for all n >= 2

# start by defining x0 and x1 as 1
def fib(N):
# takes N >= 0 and returns Nth Fibonacci number
  if N == 0 or N == 1:
    return 1
  else:
    return fib(N-1) + fib(N-2)

# checking some values
for i in range(10):
  print(fib(i))

"""Problem 3: Define a recursive function fact(n) which takes as input a nonnegative integer n, and outputs n!, the factorial of n."""

def fact(n):
  if n == 0:
    return 1
  else:
    return n * fact(n-1)

"""#**BISECTION METHOD**"""

# Using the intermediate value theorum to approximate zeros for continuous functions

def f(x):
   return np.sin(x)

a= -1
b= 1
n= 5

for i in range(n):
   d = (a + b)/2
   if f(d) < 0:
      a = d
   else:
      b = d
print(d)

"""Problem 4: let f(x) = x**2 + x - 5 with a, b = 0, 2. Using the bisection method, approximate the value of the zero of f in the interval [0,2] to within 12 decimal places of the actual answer. Save the answer as a variable named root."""

def f(x):
  # def the function for use in roots()
   return x**2 +x -5


def roots(a, b, n):
  # uses the bisection method to find the roots of f(x)
  # takes a and b as starting points and n as max number of tries
  for i in range(n):
    d = (a + b)/2
    if f(d) < 0:
        a = d
    else:
        b = d
  return d

root = roots(0, 2, 75)

root

"""#**NEWTON'S METHOD**

Problem 5: Define two functions g(x) and g_prime(x) which take as input a value x and return the values of g(x) = x**4 - 2x**3 - 17x**2 + 4x + 30 and g'(x) = 4x**3 - 6x**2 - 34x + 4 respectively.

Test cases: g(7) should output 940 and g_prime(-2) should output 16.
"""

def g(x):
  return x**4 - 2*x**3 - 17*x**2 + 4*x + 30

def g_prime(x):
  return 4*x**3 - 6*x**2 - 34*x + 4

g(7), g_prime(-2)

"""Problem 6: Define a function newtons_method(starting_guess, n) which takes as input a real number starting_guess and a positive integer n, and returns the value obtained by performing n iterations of Newton's method on g(x) using the starting guess x0 = starting_guess.

In other words, if x0 = starting_guess, then newtons_methods(starting_guess, n) should return the value of xN obtained by using Newton's method.

Test case: newtons_method(10, 5) should return 5.0084530919691765.
"""

def newtons_method(starting_guess, n):
  x_j = starting_guess
  for i in range(n):
    x_j -= g(x_j)/g_prime(x_j)
  return x_j

newtons_method(10,5)

"""#**MACHINE PRECISION, ROUNDOFF ERROR, AND NUMERICAL STABILITY**

Problem 7: Write a function called integration(m) that takes as input the integer m and, using the algorithm below and returns the value of the integral E_m above.
Make certain that you index this correctly, i.e, E0 = 1-1/e, and not E1 = 1-1/e. Be very careful with how Python indexes if you try to do this as an indexed array.

Test case: integration(10) should return 0.0838770700582927.
"""

def integration(m):
  # integrates the specified function on [0, m]
    E = 1 - 1/np.exp(1)

    for j in range(m):
        E = 1 - (j + 1) * E

    return E