# -*- coding: utf-8 -*-
"""lab 08 practice

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1nBWZdy1-Urzbvl-Qm6PUNBlv4j5DAisw
"""

import numpy as np

import pandas as pd
from matplotlib import pyplot as plt

df = pd.read_csv('cougar.csv')
cougar=df.values
cougar

"""#**Problem 1**#"""

# This function reads in a vector and outputs the transformed vector Ax.
def transform(x):
  # Define the transformation matrix
  A = np.array([[2, 1], [1, -3], [0, 1]])

  # Apply the transformation by matrix multiplication
  result = np.dot(A, x)

  return result

"""#**Problem 2**#

"""

def showplot(H):
  # This function displays the image produce by the collection of coordinates given in H
  cougarplot=plt.plot(H[0,:],H[1,:],'k.',markersize=3.5)
  plt.axis([-1.5,1.5,-1.5,1.5])
  plt.gca().set_aspect("equal")
  plt.show()
  return None


# Let's test the function above by plotting the data in our NumPy array cougar
showplot(cougar)

import numpy as np

def stretch(image, a, b):
    # Create the transformation matrix
    transformation_matrix = np.array([[a, 0], [0, b]])

    # Apply the linear transformation to the image
    transformed_image = np.dot(transformation_matrix, image)

    return transformed_image

# This function should take a matrix of coordinates, and output a matrix which corresponds to
# the image that has been sheared by a horizantal factor of a and a vertical factor of b

def shear(image, a, b):
    # Create the transformation matrix
    shear_matrix = np.array([[1, a], [b, 1]])

    # Apply the linear transformation to the image
    transformed_image = np.dot(shear_matrix, image)

    return transformed_image

showplot(shear(cougar, 1/2, 0))

# This function should take a matrix of coordinates, and output a matrix which corresponds to the image that has been reflected in the
# line spanned by the vector [a,b]^T

def reflect(image,a,b):
  # Create the transformation matrix
    reflect_matrix = (1/(a*a + b*b)) * np.array([[a*a - b*b, 2*a*b], [2*a*b, b*b - a*a]])

    # Apply the linear transformation to the image
    transformed_image = np.dot(reflect_matrix, image)

    return transformed_image

showplot(reflect(cougar, 1/2, 1))

# This function should take a matrix of coordinates, and output a matrix which corresponds to the image that has been rotated in the
# counterclockwise direction by an angle of theta radians.

def rotate(image,theta):
  # Create the transformation matrix
    rotate_matrix = np.array([[np.cos(theta), -np.sin(theta)], [np.sin(theta), np.cos(theta)]])

    # Apply the linear transformation to the image
    transformed_image = np.dot(rotate_matrix, image)

    return transformed_image

showplot(rotate(cougar, 3*np.pi/2))

"""#**Problem 3**#"""

iden = np.array([[1, 0], [0, 1]])

a = stretch(iden, 1/2, 1) # stretch vertically by factor of 2
c = rotate(a, -1*np.pi/4) # rotate pi/4 radians clockwise
b = reflect(c, 2, -3) # reflect over the line 2y = -3x
d = strech(b, 1, 2) # stretch horizontally by a factor of 1/2

comp_matrix = d

"""#**Problem 4**#"""

def area(A):
    e1 = np.array([1, 0])
    e2 = np.array([0, 1])

    # Calculate the vectors T(e1) and T(e2)
    Te1 = np.dot(A, e1)
    Te2 = np.dot(A, e2)

    # Calculate the lengths of T(e1) and T(e2)
    norm_Te1 = np.linalg.norm(Te1)
    norm_Te2 = np.linalg.norm(Te2)

    # Calculate the angle theta between T(e1) and T(e2)
    cos_theta = np.dot(Te1, Te2) / (norm_Te1 * norm_Te2)
    theta = np.arccos(cos_theta)

    # Calculate the area of the parallelogram T(U)
    area_TU = norm_Te1 * norm_Te2 * np.sin(theta)

    return area_TU

area(np.array([[1,3],[2,-1]]))

"""#**Problem 5**#"""

# Save the values of the determinants of the matrices A,B,C, and D from Problem 5.

detM = 10

detN = -5

detP = 3

detQ = -0.2

"""#**Problem 6**#"""

# Save the values of the matrix A and the area of the ellipse from Problem 6.

ellipse_matrix = np.array([[1.5, 0.5], [1, -2.75]])

# Calculate the area of the ellipse using the determinant of A
ellipse_area = np.pi * np.linalg.det(ellipse_matrix)

"""#**Problem 7**#"""

# Save the values of the determinants of the matrices B1,B3,B6, and B0 from Problem 5.
B1 = np.array([[4, 3], [2, 6]])
detB1=np.linalg.det(B1)

B3 = np.array([[1.5, 3], [2, 6]])
detB3=np.linalg.det(B3)

B6 = np.array([[1.00001, 3], [2, 6]])
detB6=np.linalg.det(B6)

B0 = np.array([[1, 3], [2, 6]])
detB0 = np.linalg.det(B0)